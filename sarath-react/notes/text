ğŸ”¹ Emmet:
Emmet is the essential toolkit for web-developers. It allows you
to type shortcuts that are then expanded into full-fledged boiler plate code for writing HTML and CSS.
Emmet is a shortcut tool for writing HTML, CSS, and JSX faster. It expands abbreviations into full code snippets, saving time. It's built into VS Code, Sublime Text, Atom, and other editors.

ğŸ”¹ React vs ReactDOM: Whatâ€™s the Difference?
In a React application, React and ReactDOM serve different roles:
Library	Purpose
react:	Core React library for components, state, hooks, and rendering logic
react-dom:	Handles interacting with the actual DOM in web applications

ğŸ”¹ What is "integrity" in package-lock.json?
The "integrity" field in package-lock.json is a security feature that ensures the package downloaded matches the expected version. It contains a cryptographic hash (SHA512 or SHA256) used to verify the integrity of the package files.

ğŸ”¹ Example of "integrity" in package-lock.json

"dependencies": {
  "lodash": {
    "version": "4.17.21",
    "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
    "integrity": "sha512-v2kDE7I2k37Xâ€¦5n6t9Q==" 
  }
}
Here:

"version" â†’ The exact version of the package.
"resolved" â†’ The URL from where the package was downloaded.
"integrity" â†’ A cryptographic hash that ensures the package hasn't been altered.
ğŸ”¹ Why is "integrity" Important?
âœ… Prevents tampering â†’ Ensures that the package is not modified after publishing.
âœ… Verifies package authenticity â†’ Protects against man-in-the-middle (MITM) attacks.
âœ… Improves performance â†’ npm can verify cached versions without re-downloading.

ğŸ”¹ When Do Integrity Issues Occur?
If you see an error like:

npm ERR! Integrity check failed

Possible reasons:

The package in node_modules does not match the hash in package-lock.json.
package-lock.json is outdated or modified incorrectly.
A corrupt or tampered package was downloaded.
ğŸ”¹ How to Fix Integrity Errors?
Try resetting dependencies:
rm -rf node_modules package-lock.json
npm install
This re-generates package-lock.json with fresh integrity hashes.

If the issue persists, force clean npm's cache:

npm cache clean --force
npm install


ğŸ”¹ What are Arrow Functions (=>) in JavaScript?
Arrow functions (=>) are a shorter and more concise way to write functions in JavaScript. They were introduced in ES6 (ECMAScript 2015) and are especially useful for callbacks, functional programming, and keeping this bound correctly.

ğŸ”¹ Syntax of Arrow Functions
âœ… Basic Example

// Traditional function
function add(a, b) {
  return a + b;
}

// Arrow function (shorter syntax)
const add = (a, b) => a + b;

console.log(add(2, 3)); // Output: 5

âœ… Single Parameter (No Parentheses Needed)
const square = x => x * x;
console.log(square(4)); // Output: 16

âœ… No Parameters (Use () or _)
const sayHello = () => "Hello, world!";
console.log(sayHello()); // Output: Hello, world!

ğŸ”¹ Advantages of Arrow Functions
âœ… Shorter and cleaner syntax
âœ… No binding of this (uses this from surrounding scope)
âœ… Implicit return (when no {} used)
âœ… Great for callbacks & functional programming

ğŸ”¹ this Behavior in Arrow Functions
One of the key differences between regular functions and arrow functions is how they handle this.

ğŸš« Traditional Functions: this Changes
const person = {
  name: "Alice",
  greet: function() {
    setTimeout(function() {
      console.log(`Hello, ${this.name}`);
    }, 1000);
  }
};
person.greet(); // âŒ `this.name` is undefined (or refers to the global object)
âœ… Arrow Functions: this Stays the Same
const person = {
  name: "Alice",
  greet: function() {
    setTimeout(() => {
      console.log(`Hello, ${this.name}`);
    }, 1000);
  }
};
person.greet(); // âœ… Output: Hello, Alice
ğŸ’¡ Arrow functions donâ€™t have their own thisâ€”they inherit this from their surrounding scope.

ğŸ”¹ Arrow Functions in Callbacks
Arrow functions are perfect for callbacks because they keep this and are concise.

âœ… Example: Array .map()
const numbers = [1, 2, 3, 4];
const squares = numbers.map(num => num * num);
console.log(squares); // Output: [1, 4, 9, 16]

âœ… Example: Event Listeners
document.getElementById("btn").addEventListener("click", () => {
  console.log("Button Clicked!");
});
ğŸ”¹ Arrow Functions with reduce, filter, find

âœ… Using reduce()
const nums = [10, 20, 30];
const sum = nums.reduce((total, num) => total + num, 0);
console.log(sum); // Output: 60

âœ… Using filter()
const evenNumbers = nums.filter(num => num % 2 === 0);
console.log(evenNumbers); // Output: [10, 20, 30]

âœ… Using find()
const users = [{ id: 1, name: "Alice" }, { id: 2, name: "Bob" }];
const user = users.find(user => user.id === 2);
console.log(user); // Output: { id: 2, name: "Bob" }
ğŸ”¹ When NOT to Use Arrow Functions
ğŸš« As Methods in Objects (because this won't refer to the object)

const person = {
  name: "Alice",
  greet: () => console.log(`Hello, ${this.name}`)
};
person.greet(); // âŒ Output: Hello, undefined
Fix: Use a regular function.

ğŸš« As Constructors (Arrow functions canâ€™t be used with new)


const Person = (name) => { this.name = name; };
const p = new Person("Alice"); // âŒ Error: Person is not a constructor
Fix: Use a regular function.

ğŸ”¹ Summary
Feature	Traditional Function	Arrow Function
Syntax	More verbose	Concise (=>)
Own this?	âœ… Yes	âŒ No (inherits this)
Own arguments?	âœ… Yes	âŒ No
Can be used as a method?	âœ… Yes	ğŸš« No
Can be used as a constructor?	âœ… Yes	ğŸš« No
Implicit return?	âŒ No	âœ… Yes (if no {})

ğŸ“Œ 1. What is NPM?
NPM (Node Package Manager) is a package manager for JavaScript.
It helps install, update, and manage dependencies (libraries, tools).
Example:
sh
Copy
Edit
npm install react
It also allows running scripts like:
sh
Copy
Edit
npm run build
ğŸ“Œ 2. What is Parcel/Webpack? Why do we need it?
ğŸ“¦ Parcel & Webpack are Bundlers
They bundle JavaScript, CSS, images, and assets into a single optimized file for production.
Helps with performance, code splitting, and optimizations.
ğŸ“Œ Why do we need bundlers?
Modular Code: They combine multiple files into a single efficient bundle.
Performance Boost: They minify and optimize assets.
Compatibility: They transpile modern JS (ES6+) into browser-compatible code.
Parcel (Zero-config, faster) vs. Webpack (Highly configurable but slower).

ğŸ“Œ 3. What is .parcel-cache?
A folder used by Parcel to store cached data for faster builds.
If you delete .parcel-cache, Parcel recompiles everything from scratch, which is slower.
ğŸ“Œ 4. What is npx?
npx (Node Package eXecute) runs npm packages without installing them globally.
Example:
sh
Copy
Edit
npx create-react-app my-app
npx downloads & runs create-react-app temporarily.
ğŸ“Œ 5. What is the difference between dependencies vs devDependencies?
dependencies â†’ Needed at runtime (React, Redux, Axios).
devDependencies â†’ Needed only for development (Babel, ESLint, Parcel).
ğŸ“Œ Example in package.json:

json
Copy
Edit
"dependencies": {
  "react": "^18.0.0"
},
"devDependencies": {
  "parcel": "^2.8.0"
}
ğŸ“Œ 6. What is Tree Shaking?
Tree shaking removes unused JavaScript from the final bundle to reduce size.
Parcel/Webpack automatically does this.
ğŸ“Œ Example:

js
Copy
Edit
import { usedFunction } from "library";
If unusedFunction exists in the library but isn't used, it won't be included in the bundle.
ğŸ“Œ 7. What is Hot Module Replacement (HMR)?
HMR updates code in the browser without refreshing the page.
Useful for fast development (Retains state).
Parcel, Webpack, and Vite support HMR.
ğŸ“Œ Example:

Changing CSS updates instantly without reloading the page.
ğŸ“Œ 8. Favourite 5 Superpowers of Parcel
ğŸ”¥ Zero Configuration â€“ No need for a config file like Webpack!
ğŸš€ Faster Builds â€“ Uses caching and parallel processing.
ğŸ“¦ Tree Shaking â€“ Removes unused code automatically.
ğŸ› ï¸ HMR (Hot Module Replacement) â€“ Updates changes instantly.
ğŸ”€ Code Splitting â€“ Loads only necessary parts of code dynamically.
âœ… Explaining 3 in Detail:

Zero Configuration: No need for Webpack-style setup; Parcel just works.
Tree Shaking: It removes unused imports, making the final bundle smaller.
HMR: No need to refresh the page manually; it updates in real-time.
ğŸ“Œ 9. What is .gitignore? What should we add and not add?
.gitignore tells Git which files NOT to track.
Common files to ignore:
bash
Copy
Edit
node_modules/
.env
dist/
.parcel-cache/
Donâ€™t ignore source code, configs, and documentation!
ğŸ“Œ 10. What is the difference between package.json and package-lock.json?
Feature	package.json	package-lock.json
Purpose	Stores project dependencies	Locks exact versions
Editable	Yes (manually)	No (auto-generated)
Versioning	Uses ^ (caret) & ~ (tilde)	Exact versions
Included in Git?	âœ… Yes	âœ… Yes
ğŸ“Œ 11. Why should I not modify package-lock.json?
It ensures consistent dependency versions across different systems.
Manually editing it can break installs.
Always let npm update it automatically.
ğŸ“Œ 12. What is node_modules? Is it a good idea to push it on Git?
node_modules is where all installed dependencies are stored.
âŒ No, do NOT push node_modules to Git because:
It's too large.
Anyone can install it using package.json (npm install).
ğŸ“Œ 13. What is the dist folder?
Contains production-ready, optimized files after running npm run build.
Used for deployment (Live websites).
ğŸ“Œ 14. What is browserslist?
Defines which browsers your app should support.
Found in package.json:
json
Copy
Edit
"browserslist": [
  ">0.2%",
  "not dead",
  "not op_mini all"
]
Helps Parcel/Webpack optimize output.
ğŸ“Œ 15. Read about different bundlers: Vite, Webpack, Parcel
Feature	Vite	Webpack	Parcel
Config Needed?	âŒ No	âœ… Yes	âŒ No
Speed	ğŸš€ Fastest	ğŸ¢ Slow	ğŸš€ Fast
HMR	âœ… Excellent	âœ… Good	âœ… Good
Code Splitting	âœ… Yes	âœ… Yes	âœ… Yes
Vite â†’ Uses esbuild, super fast.
Webpack â†’ More flexible, but complex.
Parcel â†’ Best for zero-config, quick setup.
ğŸ“Œ 16. Read about ^ (caret) and ~ (tilde) in package.json
Symbol	Example	Meaning
^ (caret)	"react": "^18.0.0"	Allows minor updates (e.g., 18.1.0 but not 19.0.0)
~ (tilde)	"react": "~18.0.0"	Allows patch updates (e.g., 18.0.1 but not 18.1.0)
ğŸ“Œ 17. Read about <script> types in HTML (MDN Docs)
Script Type	Example	Purpose
Default (<script>)	<script src="app.js"></script>	Runs immediately
async	<script async src="app.js"></script>	Loads in parallel, runs when ready
defer	<script defer src="app.js"></script>	Loads in parallel, runs after HTML is parsed
module	<script type="module" src="app.js"></script>	Supports ES6 modules
ğŸ“Œ Best practice: Use defer for scripts that interact with the DOM.

ğŸš€ Summary
âœ… Bundlers like Parcel/Webpack optimize JS & assets
âœ… Tree Shaking removes unused code
âœ… HMR makes dev faster
âœ… Never push node_modules to Git
âœ… package-lock.json should NOT be modified manually
âœ… Use browserslist to optimize for specific browsers